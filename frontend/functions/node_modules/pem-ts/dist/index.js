"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PEMObject = exports.PEMError = exports.rfc7468CompliantPEMLabels = void 0;
const base64_js_1 = require("base64-js");
exports.rfc7468CompliantPEMLabels = [
    "X509 CERTIFICATE",
    "CERTIFICATE",
    "CERTIFICATE PAIR",
    "TRUSTED CERTIFICATE",
    "NEW CERTIFICATE REQUEST",
    "CERTIFICATE REQUEST",
    "X509 CRL",
    "ANY PRIVATE KEY",
    "PUBLIC KEY",
    "RSA PRIVATE KEY",
    "RSA PUBLIC KEY",
    "DSA PRIVATE KEY",
    "DSA PUBLIC KEY",
    "PKCS7",
    "PKCS #7 SIGNED DATA",
    "ENCRYPTED PRIVATE KEY",
    "PRIVATE KEY",
    "DH PARAMETERS",
    "SSL SESSION PARAMETERS",
    "DSA PARAMETERS",
    "ECDSA PUBLIC KEY",
    "EC PARAMETERS",
    "EC PRIVATE KEY",
    "PARAMETERS",
    "CMS",
    "ATTRIBUTE CERTIFICATE",
];
class PEMError extends Error {
    constructor(m) {
        super(m);
    }
}
exports.PEMError = PEMError;
class PEMObject {
    static preEncapsulationBoundaryRegex = /^-----BEGIN ([ \x21-\x7e]+)-----$/m;
    static postEncapsulationBoundaryRegex = /^-----END ([ \x21-\x7e]+)-----$/m;
    static base64LineRegex = /^[A-Za-z0-9+/=]+\s*$/mg;
    static pemObjectRegex = new RegExp(PEMObject.preEncapsulationBoundaryRegex.source
        + "\r?\n(?:\\s*\r?\n)*((?:"
        + PEMObject.base64LineRegex.source
        + "\r?\n)*)?"
        + PEMObject.postEncapsulationBoundaryRegex.source, "m");
    static validateLabel(label) {
        if (!label.match(/^[A-Z#0-9 ]*$/))
            throw new PEMError("Malformed PEM label.");
        if (label.match(/\s\s/))
            throw new PEMError("PEM label cannot contain consecutive spaces.");
        if (label.match(/--/))
            throw new PEMError("PEM label cannot contain consecutive hyphen-minuses.");
        if (label.match(/^\s+/) || label.match(/\s+$/)) {
            throw new PEMError("PEM label cannot begin or end with spaces.");
        }
        if (label.match(/^-+/) || label.match(/-+$/)) {
            throw new PEMError("PEM label cannot begin or end with hyphen-minuses.");
        }
    }
    static parse(text) {
        let i = 0;
        let match;
        const ret = [];
        do {
            match = PEMObject.pemObjectRegex.exec(text.slice(i));
            if (match === null)
                break;
            i += (match.index + 1);
            const next = new PEMObject(match[1], match[2].replace(/\s+/ug, ""));
            ret.push(next);
        } while (i < text.length);
        return ret;
    }
    _label = "";
    get label() {
        PEMObject.validateLabel(this._label);
        return this._label;
    }
    set label(value) {
        PEMObject.validateLabel(value);
        this._label = value;
    }
    data = new Uint8Array(0);
    get hasRFC7468CompliantLabel() {
        return exports.rfc7468CompliantPEMLabels.includes(this._label);
    }
    get preEncapsulationBoundary() {
        return `-----BEGIN ${this.label}-----`;
    }
    get postEncapsulationBoundary() {
        return `-----END ${this.label}-----`;
    }
    get encapsulatedTextPortion() {
        const base64data = (0, base64_js_1.fromByteArray)(this.data);
        const stringSplitter = /.{1,64}/g;
        return (base64data.match(stringSplitter) || []).join("\n");
    }
    constructor(label, data) {
        if (label !== undefined)
            this.label = label;
        if (data !== undefined) {
            if (typeof data === "string") {
                this.data = (0, base64_js_1.toByteArray)(data);
            }
            else {
                this.data = data;
            }
        }
    }
    decode(encoded) {
        const lines = encoded.trim().replace("\r", "").split("\n");
        if (lines.length <= 2)
            throw new PEMError("PEM is too small to be valid");
        if (lines[0].indexOf("-----BEGIN ") !== 0)
            throw new PEMError("PEM object did not start with '-----BEGIN '");
        if (!lines[0].endsWith("-----"))
            throw new PEMError("PEM object did not end with '-----'");
        const preEncapsulationBoundaryLabel = lines[0].slice(11, (lines[0].length - 5));
        if (lines[(lines.length - 1)].indexOf("-----END ") !== 0) {
            throw new PEMError("Last line of PEM object did not start with '-----END '");
        }
        if (!lines[(lines.length - 1)].endsWith("-----")) {
            throw new PEMError("Last line of PEM object did not end with '-----'");
        }
        const postEncapsulationBoundaryLabel = lines[(lines.length - 1)].slice(9, (lines[(lines.length - 1)].length - 5));
        if (preEncapsulationBoundaryLabel !== postEncapsulationBoundaryLabel) {
            throw new PEMError("PEM object Pre-encapsulation Boundary label does not match Post-encapsulation Boundary label.");
        }
        this.label = preEncapsulationBoundaryLabel;
        let firstNonBlankBase64Line = 1;
        while (firstNonBlankBase64Line < (lines.length - 1)) {
            if (!lines[firstNonBlankBase64Line].match(/^\s*$/))
                break;
            firstNonBlankBase64Line++;
        }
        lines.slice(firstNonBlankBase64Line, (lines.length - 1)).forEach((line) => {
            if (line.match(/^\s*$/))
                throw new PEMError("Blank lines detected within PEM data");
        });
        const base64data = lines.slice(1, (lines.length - 1)).join("").replace(/\s+/g, "");
        this.data = (0, base64_js_1.toByteArray)(base64data);
    }
    get encoded() {
        return (this.preEncapsulationBoundary + "\n"
            + this.encapsulatedTextPortion + "\n"
            + this.postEncapsulationBoundary);
    }
}
exports.PEMObject = PEMObject;
//# sourceMappingURL=index.js.map